export const DBTransactionStatus={SUCCESS:"SUCCESS",ERROR:"ERROR"};function t(t){return function*(){yield*t}()}function e(){let t;return[new Promise((e=>{t=e})),t]}function n(t,e){return{status:t,data:e}}export class AsyncDB{#t;#e;#n;#r;#s;constructor(t=!1){if(this.#s=t,this.#e=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,!this.#e)throw Error("Your browser doesn't support a stable version of IndexedDB.")}get version(){return this.#r}get dbName(){return this.#n}get transaction(){return window.IDBTransaction||window.webkitIDBTransaction||window.msIDBTransaction}get keyRange(){return window.IDBKeyRange||window.webkitIDBKeyRange||window.msIDBKeyRange}get nativeDB(){return this.#t}#a(t,e){if(!e.name||!e.keyPath)throw Error("createIndex requires name and keyPath");t.createIndex(e.name,e.keyPath,e.options||{})}#o(t){const e=this,n=t.next();if(n.done)return;const r=n.value,s=r.name,a=r.options||{},o=r.indices||[];if(!s)throw Error("Table name is required");{const n=this.#t.createObjectStore(s,a);o.length>0&&o.forEach((t=>{e.#a(n,t)})),n.transaction.oncomplete=n=>{e.#o(t)}}}#i(t,e){const n=this,r=e.next();if(r.done)return;t.add(r.value).onsuccess=r=>{n.#i(t,e)}}setup(r,s,a=[]){const o=this;this.#n=r,this.#r=s;const[i,c]=e(),u=this.#e.open(r,s);return u.onsuccess=t=>{o.#t=t.target.result,c(n(DBTransactionStatus.SUCCESS,"Database setup successful"))},u.onerror=t=>{c(n(DBTransactionStatus.ERROR,t))},u.onupgradeneeded=e=>{if(o.#t=e.target.result,1===s){let e=t(a);o.#o(e)}e.target.transaction.oncomplete=t=>{c(n(DBTransactionStatus.SUCCESS,"Database setup successful"))}},i}getDataCursor(t,r,s="",a="next"){const[o,i]=e(),c=[],u=this.#t.transaction([t],"readonly"),d=u.objectStore(t).index(r);let S;return S=s?d.openCursor(s,a):d.openCursor(),u.onerror=t=>{i(n(DBTransactionStatus.ERROR,t))},S.onsuccess=t=>{const e=S.result;if(e){const t=e.value;t&&c.push(t),e.continue()}else i(n(DBTransactionStatus.SUCCESS,c))},S.onerror=t=>{i(n(DBTransactionStatus.ERROR,t))},o}getAll(t){const[r,s]=e(),a=this.#t.transaction([t],"readonly").objectStore(t).getAll();return a.onsuccess=t=>{s(n(DBTransactionStatus.SUCCESS,t.target.result))},a.onerror=t=>{s(n(DBTransactionStatus.ERROR,t))},r}getAll(t,r){const[s,a]=e(),o=this.#t.transaction([t],"readonly").objectStore(t).getAll(r);return o.onsuccess=t=>{a(n(DBTransactionStatus.SUCCESS,t.target.result))},o.onerror=t=>{a(n(DBTransactionStatus.ERROR,t))},s}getAll(t,r,s){const[a,o]=e(),i=this.#t.transaction([t],"readonly").objectStore(t).getAll(r,s);return i.onsuccess=t=>{o(n(DBTransactionStatus.SUCCESS,t.target.result))},i.onerror=t=>{o(n(DBTransactionStatus.ERROR,t))},a}setData(r,s=[]){const[a,o]=e(),i=this.#t.transaction([r],"readwrite"),c=i.objectStore(r),u=t(s);return this.#i(c,u),i.oncomplete=t=>{o(n(DBTransactionStatus.SUCCESS))},i.onerror=t=>{o(n(DBTransactionStatus.ERROR,t))},a}updateData(t,r,s){const[a,o]=e(),i=this.#t.transaction([t],"readwrite").objectStore(t),c=i.get(r);return c.onsuccess=t=>{const e=c.result,r=(Object.assign(e,s),i.put(e));r.onsuccess=()=>{o(n(DBTransactionStatus.SUCCESS,!0))},r.onerror=t=>{o(n(DBTransactionStatus.ERROR,t))}},c.onerror=t=>{o(n(DBTransactionStatus.ERROR,t))},a}deleteData(t,r){const[s,a]=e(),o=this.#t.transaction([t],"readwrite");return o.objectStore(t).delete(r),o.oncomplete=t=>{a(n(DBTransactionStatus.SUCCESS,!0))},o.onerror=t=>{a(n(DBTransactionStatus.ERROR,t))},s}deleteDatabase(){this.#e.deleteDatabase(this.#n),this.#t=null}bulkPut(t,r,s){const[a,o]=e(),i=this.#t.transaction([t],"readwrite").objectStore(t),c=s?i.put(r,s):i.put(r);return c.onsuccess=t=>{o(n(DBTransactionStatus.SUCCESS))},c.onerror=t=>{o(n(DBTransactionStatus.ERROR,t))},a}}